// generated by Fast Light User Interface Designer (fluid) version 1.0107

#include "Nodul.h"
IplImage *numune;
uchar lut[256];
CvMat* lut_mat;
Fl_OpenCV *Pict;

Fl_Button *Open=(Fl_Button *)0;

Fl_Scroll *Board=(Fl_Scroll *)0;

Fl_Browser *Data=(Fl_Browser *)0;

Fl_Output *FName=(Fl_Output *)0;

Fl_Button *Bul=(Fl_Button *)0;

static void cb_Bul(Fl_Button*, void*) {
  Data->clear();
FindNodule();
Board->redraw();
}

Fl_Double_Window* make_window() {
  Fl_Double_Window* w;
  { Fl_Double_Window* o = new Fl_Double_Window(505, 669, "Nodul Say\375s\375  by BlueKid");
    w = o;
    o->box(FL_PLASTIC_UP_BOX);
    o->color(FL_SELECTION_COLOR);
    { Fl_Button* o = Open = new Fl_Button(396, 4, 30, 26, "...");
      o->tooltip("Open");
      o->box(FL_PLASTIC_UP_BOX);
      o->color((Fl_Color)14);
      o->labelfont(1);
      o->labelsize(18);
      o->callback((Fl_Callback*)Open_CB);
    }
    { Fl_Scroll* o = Board = new Fl_Scroll(11, 40, 480, 480);
      o->color((Fl_Color)23);
      Pict=new Fl_OpenCV(11,40);
      Board->add(Pict);
      o->end();
    }
    { Fl_Browser* o = Data = new Fl_Browser(11, 531, 484, 128);
      o->box(FL_DOWN_BOX);
    }
    FName = new Fl_Output(74, 6, 312, 24, "Numune :");
    { Fl_Button* o = Bul = new Fl_Button(436, 4, 59, 26, "Bul");
      o->tooltip("Open");
      o->box(FL_PLASTIC_UP_BOX);
      o->color((Fl_Color)14);
      o->labelfont(1);
      o->labelsize(18);
      o->callback((Fl_Callback*)cb_Bul);
      o->deactivate();
    }
    o->end();
  }
  return w;
}

int main(int argc, char **argv) {
  Fl_Window  * window;
numune=0;
window = make_window( );
window->show( argc, argv );
return ( Fl :: run( ) );
  return Fl::run();
}

void Open_CB(Fl_Widget*,void*) {
  char* file;

file = fl_file_chooser("Open", "Picture (*.{jpg,png,bmp,dib,sr,ras,pbm,pgm,ppm,tif,tiff})\t", 0);
if(file==NULL) return;
FName->value(file);

if(numune)
 cvReleaseImage(&numune);

Pict->Load(file, 1); 
numune= cvLoadImage( file, 0 );
Data->clear();
Board->redraw();
Bul->activate();
}

void GetIdentty(IplImage *image, fann_type *ID) {
  char Buf[500];
IplImage*d_image;
    d_image = cvCloneImage(image);
    lut_mat = cvCreateMatHeader( 1, 256, CV_8UC1 );
    cvSetData( lut_mat, lut, 0 );

    int brightness =-100;
    int contrast = 100;
    int i;

    if( contrast > 0 )
    {
        double delta = 127.*contrast/100;
        double a = 255./(255. - delta*2);
        double b = a*(brightness - delta);
        for( i = 0; i < 256; i++ )
        {
            int v = cvRound(a*i + b);
            if( v < 0 )
                v = 0;
            if( v > 255 )
                v = 255;
            lut[i] = (uchar)v;
        }
    }
    else
    {
        double delta = -128.*contrast/100;
        double a = (256.-delta*2)/255.;
        double b = a*brightness + delta;
        for( i = 0; i < 256; i++ )
        {
            int v = cvRound(a*i + b);
            if( v < 0 )
                v = 0;
            if( v > 255 )
                v = 255;
            lut[i] = (uchar)v;
        }
    }

    cvLUT( image, d_image, lut_mat );


    IplImage *image02 = 0, *image03 = 0, *image04 = 0;

    image03 = cvCloneImage( d_image );

    cvSmooth( d_image, image03, CV_MEDIAN ,3, 0,0,0 );

    cvShowImage( "image", image03 );

    image02 = cvCloneImage( image03 );
    image04 = cvCloneImage( image03 );

    CvMemStorage* stor;
    CvSeq* cont;
    CvBox2D32f* box;
    CvPoint* PointArray;
    CvPoint2D32f* PointArray2D32f;

    // Create dynamic structure and sequence.
    stor = cvCreateMemStorage(0);
    cont = cvCreateSeq(CV_SEQ_ELTYPE_POINT, sizeof(CvSeq), sizeof(CvPoint) , stor);

    // Threshold the source image. This needful for cvFindContours().
    cvThreshold( image03, image02, 70, 255, CV_THRESH_TRUNC );

    // Find all contours.
    cvFindContours( image02, stor, &cont, sizeof(CvContour),
                    CV_RETR_LIST, CV_CHAIN_APPROX_NONE, cvPoint(0,0));

    // Clear images. IPL use.
    cvZero(image02);
    cvZero(image04);

    // This cycle draw all contours and approximate it by ellipses.
    int j=0;
    double ortR=0.0;
    double ortA=0.0;
    Data->add("@b@C1Bulunan Nodüller");
    for(;cont;cont = cont->h_next)
    {
        int i; // Indicator of cycle.
        int count = cont->total; // This is number point in contour
        CvPoint center;
        CvSize size;

        if( count < 32 )
            continue;

        // Alloc memory for contour point set.
        PointArray = (CvPoint*)malloc( count*sizeof(CvPoint) );
        PointArray2D32f= (CvPoint2D32f*)malloc( count*sizeof(CvPoint2D32f) );

        // Alloc memory for ellipse data.
        box = (CvBox2D32f*)malloc(sizeof(CvBox2D32f));

        // Get contour point set.
        cvCvtSeqToArray(cont, PointArray, CV_WHOLE_SEQ);

        // Convert CvPoint set to CvBox2D32f set.
        for(i=0; i<count; i++)
        {
            PointArray2D32f[i].x = (float)PointArray[i].x;
            PointArray2D32f[i].y = (float)PointArray[i].y;
        }

        // Fits ellipse to current contour.
        cvFitEllipse(PointArray2D32f, count, box);

        // Draw current contour.
        cvDrawContours(image04,cont,CV_RGB(255,255,255),CV_RGB(255,255,255),0,1,8,cvPoint(0,0));

        // Convert ellipse data from float to integer representation.
        center.x = cvRound(box->center.x);
        center.y = cvRound(box->center.y);
        size.width = cvRound(box->size.width*0.5);
        size.height = cvRound(box->size.height*0.5);
        box->angle = -box->angle;


        if(size.height!=0 && size.height < 200 && size.width < 200) {
           float rt=(float)size.width/size.height;

           if(rt >= 0.1 && rt <= 10.0 ){
             ortR+=(float)(size.width+size.height)/2;
             ortA+=(float)(size.width*size.height);
             cvEllipse(Pict->image, center, size,
                  box->angle, 0, 360,
                  CV_RGB(0,0,255), 2, CV_AA, 0);
             sprintf(Buf,"No = %d Merkez ( %d , %d ) Ebatlar (En ,Boy) ( %d , %d ) ",++j,center.x,center.y,size.width,size.height);
             Data->add(Buf);

           }

        }

        // Free memory.

        free(PointArray);
        free(PointArray2D32f);
        free(box);

 }


    sprintf(Buf,"Nodul Sayýsý %d Ortalama R : %0.3f ",j,ortR/j); 
    Data->add(Buf);
    ID[0]=(double)j/120;
    ID[1]=ortR/(j*30.0);
}

void FindNodule() {
  char Buf[500];
fann_type *sonuc;
fann_type in[2];
struct fann *ann;
GetIdentty(numune,in);
if(in[0]!=0){
  ann=fann_create_from_file("nodul.net");
  sonuc = fann_run(ann, in);
  sprintf(Buf,"Sonuc %f  Nodül/mm2 = %.0f",*sonuc,*sonuc*25/0.08);
  Data->add(Buf);
  float t,f=*sonuc/0.08;
  t=f-(int)f;
  if(t>0.5)
    f+=1;
  sprintf(Buf,"@m@b@C1Nodül/mm2 = %d",((int)f)*25);
  Data->add(Buf);
  fann_destroy( ann );  
}
else
  Data->add("Nodul Sayýsý Tepit edilemedi !");


Data->topline(Data->size());
}
