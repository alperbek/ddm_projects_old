// generated by Fast Light User Interface Designer (fluid) version 1.0107

#include "PathFinder.h"
map_t map;
short *cells;

Fl_Counter *X_limit=(Fl_Counter *)0;

Fl_Counter *Y_limit=(Fl_Counter *)0;

static void cb_Random(Fl_Button*, void*) {
  int iy,ix;
int x_limit, y_limit;
x_limit=(int)X_limit->value();
y_limit=(int)Y_limit->value();
Map->clear();
Map->position(0,0); // reset scroller
Map->begin(); // begin adding children

Cell *c;
// srand(time(NULL));
for (iy = 0; iy < y_limit; ++iy) {
	for (ix = 0; ix < x_limit; ++ix) {
            c=new Cell(ix*15+Map->x(),iy*15+Map->y());
            if ((ix == 0 && iy == 0) || (ix == x_limit-1 && iy == y_limit-1))
               c->check(false);
	    else if (rand()%100 > 65)
               c->check(true);
            else
               c->check(false);

            Map->add(c);

	}

}

Map->end();
Map->redraw();
}

static void cb_Find(Fl_Button*, void*) {
  int ix, iy;
pathfinder_t *pf;
list_t *path;
int c;
char a;
int cost;
int result;
int st_x, st_y, tar_x, tar_y, st, tar;
list_iterator_t lit;
int x_limit, y_limit;
x_limit=(int)X_limit->value();
y_limit=(int)Y_limit->value();

cells = (short*)malloc(x_limit*y_limit*sizeof(short));
for (iy = 0; iy < y_limit; iy++) {   // dosyadan okuyor
	for (ix = 0; ix < x_limit; ix++) {
	   Cell *c=(Cell*)Map->child(POS(ix, iy, x_limit));
	   cells[POS(ix, iy, x_limit)] = c->checked;
	}
}
pf = pfAlloc(x_limit*y_limit, x_limit*y_limit);
map.x_limit = x_limit;
map.y_limit = y_limit;
st_x = st_y = 0;  // baþlangýç
tar_x = x_limit-1; tar_y = y_limit-1; // hedef
st = POS(st_x, st_y, x_limit); // baþlangýç
tar = POS(tar_x, tar_y, x_limit); // hedef
map.cells = cells;
pfSetMap(pf, &map);
path = lAlloc();
result = pfFindPath(pf, st, tar, path, &cost);
if (result == SOLVED) {
     fl_message(" Solved\n Cost: %d\n", cost);

        for (lit = path->front; lit != 0; lit = lit->next){
           Cell *c=(Cell*)Map->child(lit->val);
           c->walk();
	}
}
else
     fl_message("No solution\n");
free(cells);
free(path);
pfFree(pf);
Map->init_sizes();
Map->position(0,0);
Map->redraw();
}

Fl_Scroll *Map=(Fl_Scroll *)0;

static void cb_Empty(Fl_Button*, void*) {
  int iy,ix;
int x_limit, y_limit;
x_limit=(int)X_limit->value();
y_limit=(int)Y_limit->value();
Map->clear();
Map->position(0,0); // reset scroller
Map->begin(); // begin adding children
Cell *c;
// srand(time(NULL));
for (iy = 0; iy < y_limit; ++iy) {
	for (ix = 0; ix < x_limit; ++ix) {
            c=new Cell(ix*15+Map->x(),iy*15+Map->y());
//            c=new Cell(Map->x()+ix*15,Map->y()+iy*15);
//            c=new Cell(ix*15,iy*15);
/*
            if ((ix == 0 && iy == 0) || (ix == x_limit-1 && iy == y_limit-1))
               c->check(false);
	    else if (rand()%100 > 65)
               c->check(true);
            else
               c->check(false);
*/
            Map->add(c);

	}

}


Map->end();
Map->redraw();
}

Fl_Double_Window* make_window() {
  Fl_Double_Window* w;
  { Fl_Double_Window* o = new Fl_Double_Window(551, 498, "Path Finder");
    w = o;
    o->color((Fl_Color)29);
    { Fl_Counter* o = X_limit = new Fl_Counter(5, 25, 110, 20, "Max X Len");
      o->type(1);
      o->box(FL_PLASTIC_UP_BOX);
      o->color((Fl_Color)1);
      o->minimum(10);
      o->maximum(1000);
      o->step(10);
      o->value(50);
      o->align(FL_ALIGN_TOP);
    }
    { Fl_Counter* o = Y_limit = new Fl_Counter(130, 25, 110, 20, "Max Y Len");
      o->type(1);
      o->box(FL_PLASTIC_UP_BOX);
      o->color((Fl_Color)1);
      o->minimum(10);
      o->maximum(1000);
      o->step(10);
      o->value(50);
      o->align(FL_ALIGN_TOP);
    }
    { Fl_Button* o = new Fl_Button(250, 5, 75, 40, "Random  Map");
      o->box(FL_PLASTIC_DOWN_BOX);
      o->color((Fl_Color)1);
      o->labelfont(3);
      o->callback((Fl_Callback*)cb_Random);
      o->align(FL_ALIGN_WRAP);
    }
    { Fl_Button* o = new Fl_Button(415, 5, 125, 40, "Find Path");
      o->box(FL_PLASTIC_DOWN_BOX);
      o->color((Fl_Color)1);
      o->labelfont(3);
      o->labelsize(18);
      o->callback((Fl_Callback*)cb_Find);
      o->align(FL_ALIGN_WRAP);
    }
    { Fl_Scroll* o = Map = new Fl_Scroll(0, 60, 550, 440);
      o->color((Fl_Color)29);
      o->end();
      Fl_Group::current()->resizable(o);
    }
    { Fl_Button* o = new Fl_Button(335, 5, 70, 40, "Empty Map");
      o->box(FL_PLASTIC_DOWN_BOX);
      o->color((Fl_Color)1);
      o->labelfont(3);
      o->callback((Fl_Callback*)cb_Empty);
      o->align(FL_ALIGN_WRAP);
    }
    o->end();
  }
  return w;
}

int main(int argc, char **argv) {
  Fl_Window  * window;


    window = make_window( );

    window->show( argc, argv );
    return ( Fl :: run( ) );
  return Fl::run();
}
