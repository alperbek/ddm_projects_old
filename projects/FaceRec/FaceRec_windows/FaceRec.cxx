// generated by Fast Light User Interface Designer (fluid) version 1.0109

#include "FaceRec.h"
vector <string> names; 
vector <string> files; 
IplImage *img,*yuzg; 
Fl_Capture Cap; 
CvMemStorage* storage; 
CvSeq* faces; 
static char* cascade_names[] ={"haarcascade_frontalface_alt.xml",
                               "haarcascade_frontalface_alt2.xml",
                               "haarcascade_frontalface_alt_tree.xml",
                               "haarcascade_frontalface_default.xml",                                                                                          
                               "haarcascade_profileface.xml",
                               "haarcascade_upperbody.xml",
                               "haarcascade_lowerbody.xml",
                               "haarcascade_fullbody.xml"                         
                               }; 
CvHaarClassifierCascade* cascade; 
Fl_OpenCV *Pict; 
Fl_OpenCV *fFace; 
bool playing,extracting; 

Fl_Double_Window *Win=(Fl_Double_Window *)0;

Fl_Scroll *Board=(Fl_Scroll *)0;

Fl_Input *Name=(Fl_Input *)0;

Fl_Button *Open=(Fl_Button *)0;

static void cb_Open(Fl_Button*, void*) {
  OpenCAM_CB();
Board->redraw();
}

Fl_Button *ExtractBut=(Fl_Button *)0;

static void cb_ExtractBut(Fl_Button*, void*) {
  ExtractBut->deactivate();
Fl::add_timeout(0.1, Extracting_CB);
}

Fl_Button *SaveBut=(Fl_Button *)0;

static void cb_SaveBut(Fl_Button*, void*) {
  Save_Add();
}

Fl_Button *Learn=(Fl_Button *)0;

static void cb_Learn(Fl_Button*, void*) {
  learn();
}

Fl_Button *Recognize=(Fl_Button *)0;

static void cb_Recognize(Fl_Button*, void*) {
  recognize();
}

Fl_Browser *List=(Fl_Browser *)0;

Fl_Browser *Out=(Fl_Browser *)0;

static void cb_(Fl_Button*, void*) {
  playing=false;
AboutDlg *ab=new AboutDlg();
ab->show();
// playing=true;
}

Fl_Double_Window* make_window() {
  { Win = new Fl_Double_Window(603, 586, "Face Recognation  ");
    Win->color((Fl_Color)31);
    { Board = new Fl_Scroll(5, 10, 330, 250);
      Board->box(FL_EMBOSSED_FRAME);
      Board->color((Fl_Color)23);
      Pict=new Fl_OpenCV(10,15,320,240);
      Board->add(Pict);
      Pict->FitWindows();
      Board->end();
    } // Fl_Scroll* Board
    { Fl_Group* o = new Fl_Group(380, 5, 60, 60);
      o->box(FL_EMBOSSED_FRAME);
      o->color((Fl_Color)23);
      o->align(129);
      fFace=new Fl_OpenCV(385,10,50,50);
      o->end();
    } // Fl_Group* o
    { Name = new Fl_Input(446, 41, 145, 24, "Name");
      Name->align(FL_ALIGN_TOP_LEFT);
    } // Fl_Input* Name
    { Open = new Fl_Button(376, 80, 215, 30, "Open Web-CAM");
      Open->box(FL_PLASTIC_UP_BOX);
      Open->color(FL_SELECTION_COLOR);
      Open->labelfont(1);
      Open->labelsize(15);
      Open->callback((Fl_Callback*)cb_Open);
    } // Fl_Button* Open
    { ExtractBut = new Fl_Button(372, 120, 218, 30, "Extract Face");
      ExtractBut->box(FL_PLASTIC_UP_BOX);
      ExtractBut->color(FL_SELECTION_COLOR);
      ExtractBut->labelfont(1);
      ExtractBut->labelsize(15);
      ExtractBut->callback((Fl_Callback*)cb_ExtractBut);
      ExtractBut->deactivate();
    } // Fl_Button* ExtractBut
    { SaveBut = new Fl_Button(372, 157, 218, 30, "Save and Add Face");
      SaveBut->box(FL_PLASTIC_UP_BOX);
      SaveBut->color(FL_SELECTION_COLOR);
      SaveBut->labelfont(1);
      SaveBut->labelsize(15);
      SaveBut->callback((Fl_Callback*)cb_SaveBut);
      SaveBut->deactivate();
    } // Fl_Button* SaveBut
    { Learn = new Fl_Button(372, 196, 218, 30, "Learn Faces");
      Learn->box(FL_PLASTIC_UP_BOX);
      Learn->color(FL_SELECTION_COLOR);
      Learn->labelfont(1);
      Learn->labelsize(15);
      Learn->callback((Fl_Callback*)cb_Learn);
    } // Fl_Button* Learn
    { Recognize = new Fl_Button(372, 235, 218, 30, "Recognize Face");
      Recognize->box(FL_PLASTIC_UP_BOX);
      Recognize->color(FL_SELECTION_COLOR);
      Recognize->labelfont(1);
      Recognize->labelsize(15);
      Recognize->callback((Fl_Callback*)cb_Recognize);
      Recognize->deactivate();
    } // Fl_Button* Recognize
    { List = new Fl_Browser(5, 284, 585, 176, "List of Faces");
      List->type(1);
      List->labelcolor((Fl_Color)4);
      List->textcolor(4);
      List->align(FL_ALIGN_TOP_LEFT);
      LoadList();
    } // Fl_Browser* List
    { Out = new Fl_Browser(5, 478, 588, 102, "Distances form Extracted face");
      Out->type(1);
      Out->selection_color((Fl_Color)9);
      Out->labelcolor((Fl_Color)1);
      Out->textcolor(1);
      Out->align(FL_ALIGN_TOP_LEFT);
    } // Fl_Browser* Out
    { Fl_Button* o = new Fl_Button(566, 5, 25, 25, "?");
      o->box(FL_PLASTIC_UP_BOX);
      o->color((Fl_Color)1);
      o->labelfont(1);
      o->labelcolor((Fl_Color)4);
      o->callback((Fl_Callback*)cb_);
    } // Fl_Button* o
    Win->end();
  } // Fl_Double_Window* Win
  return Win;
}

int main(int argc, char **argv) {
  Fl_Window  * window;
img=0;
storage = 0;
cascade = 0;
playing=false;
window = make_window( );
window->show( argc, argv );
return ( Fl :: run( ) );
  return Fl::run();
}

void OpenCAM_CB() {
  if(!Cap.CaptureFromCAM(-1)) return;
LoadHaarClassifier();
Pict->SetImage(Cap.GetFrame());
Board->redraw();
playing=true;
Fl::add_timeout(0.05, Playing_CB);
ExtractBut->activate();
SaveBut->activate();
Open->deactivate();
}

void LoadHaarClassifier() {
  if(cascade )
  cvReleaseHaarClassifierCascade(&cascade);

cascade = (CvHaarClassifierCascade*)cvLoad( cascade_names[0], 0, 0, 0 );
  
if( !cascade )
{
    fl_alert("Sýnýflandýrýcý yüklenemedi ! ");

    exit(-1);
}
storage = cvCreateMemStorage(0);
}

void Playing_CB(void*) {
  if(playing==false) return;
img=Cap.GetFrame();
// detect_and_draw();
Pict->SetImage(img);
Board->redraw();
Fl::wait(0);

Fl::add_timeout(0.01, Playing_CB);
}

void Extracting_CB(void*) {
  if(extracting) return;

if(ExtractFace()){
  fFace->redraw();
  ExtractBut->activate();
  Recognize->activate();
}
else
  Fl::add_timeout(0.1, Extracting_CB);
// Fl::wait(0);
}

bool ExtractFace() {
  //
    playing=false;
    extracting=true;
    double scale = 1.3;
    IplImage *yuz,*yuzt;    
    bool ret=false;
    IplImage* gray = cvCreateImage( cvSize(img->width,img->height), 8, 1 );
    IplImage* small_img = cvCreateImage( cvSize( cvRound (img->width/scale),
                         cvRound (img->height/scale)),
                     8, 1 );

    cvCvtColor( img, gray, CV_BGR2GRAY );
    cvResize( gray, small_img, CV_INTER_LINEAR );
    cvEqualizeHist( small_img, small_img );
    cvClearMemStorage( storage );

    if( cascade )
    {
        if(faces) cvClearSeq( faces );
        faces = cvHaarDetectObjects( small_img, cascade, storage,
                                            1.1, 2, 0/*CV_HAAR_DO_CANNY_PRUNING*/,
                                            cvSize(30, 30) );

        if(faces->total){
          CvPoint leftup,rightdown;
          CvRect* r = (CvRect*)cvGetSeqElem( faces, 0 );
          leftup.x = cvRound(r->x *scale);
          leftup.y = cvRound(r->y *scale);
          rightdown.x = cvRound((r->x + r->width)*scale);
          rightdown.y = cvRound((r->y + r->height)*scale);
          cvSetImageROI(img, cvRect( leftup.x, leftup.y, rightdown.x-leftup.x,rightdown.y-leftup.y ) );
          yuz=cvCreateImage( cvSize( rightdown.x-leftup.x,rightdown.y-leftup.y), img->depth, img->nChannels );
          cvCopy( img,yuz);
          yuzt=cvCreateImage( cvSize( 50,50), img->depth, img->nChannels );
//          yuzt->widthStep=yuzt->width*yuzt->nChannels;
          yuzg = cvCreateImage( cvSize( 50,50), 8, 1 );
          yuzg->widthStep=yuzg->width*yuzg->nChannels;
          cvResize( yuz,yuzt,CV_INTER_LINEAR );
          cvCvtColor( yuzt, yuzg, CV_BGR2GRAY );
          cvEqualizeHist( yuzg, yuzg );
          fFace->SetImage(yuzg);
          ret=true;
          cvReleaseImage( &yuz );
          cvReleaseImage( &yuzt );   
                   
        }
        
        
    }

    cvReleaseImage( &gray );
    cvReleaseImage( &small_img );
    extracting=false;
    playing=true;
    return ret;
}

void learn() {
  int i, offset;

// load training data
nTrainFaces = loadFaceImgArray("train.txt");
if( nTrainFaces < 2 )
{
	fl_alert("Need 2 or more training faces\n"
	        "Input file contains only %d\n", nTrainFaces);
	return;
}
// do PCA on the training faces
doPCA();

// project the training images onto the PCA subspace
projectedTrainFaceMat = cvCreateMat( nTrainFaces, nEigens, CV_32FC1 );
offset = projectedTrainFaceMat->step / sizeof(float);
for(i=0; i<nTrainFaces; i++)
{
	//int offset = i * nEigens;
	cvEigenDecomposite(
		faceImgArr[i],
		nEigens,
		eigenVectArr,
		0, 0,
		pAvgTrainImg,
		//projectedTrainFaceMat->data.fl + i*nEigens);
		projectedTrainFaceMat->data.fl + i*offset);
}
	// store the recognition data as an xml file
storeTrainingData();
}

void recognize() {
  int i;
// nTestFaces  = 0;         // the number of test images
CvMat * trainPersonNumMat = 0;  // the person numbers during training
float * projectedTestFace = 0;
char Buf[50];
        // load test images and ground truth for person number
// nTestFaces = loadFaceImgArray("test.txt");
// printf("%d test faces loaded\n", nTestFaces);
	// load the saved training data
if( !loadTrainingData( &trainPersonNumMat ) ) return;
	// project the test images onto the PCA subspace
projectedTestFace = (float *)cvAlloc( nEigens*sizeof(float) );
for(i=0; i<1; i++)
{
	int iNearest, nearest;
		// project the test image onto the PCA subspace
	cvEigenDecomposite(
		fFace->image,
		nEigens,
		eigenVectArr,
		0, 0,
		pAvgTrainImg,
		projectedTestFace);
	iNearest = findNearestNeighbor(projectedTestFace);
//        truth    = personNumTruthMat->data.i[i];
	nearest  = trainPersonNumMat->data.i[iNearest];
        sscanf(List->text(nearest),"%s",Buf);
	fl_message("Nearest Face = %d - %s", nearest,Buf);
	
        List->select(nearest);
        Out->select(nearest);
}
}

void doPCA() {
  int i;
	CvTermCriteria calcLimit;
	CvSize faceImgSize;

	// set the number of eigenvalues to use
	nEigens = nTrainFaces-1;

	// allocate the eigenvector images
	faceImgSize.width  = faceImgArr[0]->width;
	faceImgSize.height = faceImgArr[0]->height;
	eigenVectArr = (IplImage**)cvAlloc(sizeof(IplImage*) * nEigens);
	for(i=0; i<nEigens; i++)
		eigenVectArr[i] = cvCreateImage(faceImgSize, IPL_DEPTH_32F, 1);

	// allocate the eigenvalue array
	eigenValMat = cvCreateMat( 1, nEigens, CV_32FC1 );

	// allocate the averaged image
	pAvgTrainImg = cvCreateImage(faceImgSize, IPL_DEPTH_32F, 1);

	// set the PCA termination criterion
	calcLimit = cvTermCriteria( CV_TERMCRIT_ITER, nEigens, 1);

	// compute average image, eigenvalues, and eigenvectors
	cvCalcEigenObjects(
		nTrainFaces,
		(void*)faceImgArr,
		(void*)eigenVectArr,
		CV_EIGOBJ_NO_CALLBACK,
		0,
		0,
		&calcLimit,
		pAvgTrainImg,
		eigenValMat->data.fl);

	cvNormalize(eigenValMat, eigenValMat, 1, 0, CV_L1, 0);
}

void storeTrainingData() {
  CvFileStorage * fileStorage;
	int i;

	// create a file-storage interface
	fileStorage = cvOpenFileStorage( "facedata.xml", 0, CV_STORAGE_WRITE );

	// store all the data
	cvWriteInt( fileStorage, "nEigens", nEigens );
	cvWriteInt( fileStorage, "nTrainFaces", nTrainFaces );
	cvWrite(fileStorage, "trainPersonNumMat", personNumTruthMat, cvAttrList(0,0));
	cvWrite(fileStorage, "eigenValMat", eigenValMat, cvAttrList(0,0));
	cvWrite(fileStorage, "projectedTrainFaceMat", projectedTrainFaceMat, cvAttrList(0,0));
	cvWrite(fileStorage, "avgTrainImg", pAvgTrainImg, cvAttrList(0,0));
	for(i=0; i<nEigens; i++)
	{
		char varname[200];
		sprintf( varname, "eigenVect_%d", i );
		cvWrite(fileStorage, varname, eigenVectArr[i], cvAttrList(0,0));
	}

	// release the file-storage interface
	cvReleaseFileStorage( &fileStorage );
}

int loadTrainingData(CvMat ** pTrainPersonNumMat) {
  CvFileStorage * fileStorage;
	int i;

	// create a file-storage interface
	fileStorage = cvOpenFileStorage( "facedata.xml", 0, CV_STORAGE_READ );
	if( !fileStorage )
	{
		fprintf(stderr, "Can't open facedata.xml\n");
		return 0;
	}

	nEigens = cvReadIntByName(fileStorage, 0, "nEigens", 0);
	nTrainFaces = cvReadIntByName(fileStorage, 0, "nTrainFaces", 0);
	*pTrainPersonNumMat = (CvMat *)cvReadByName(fileStorage, 0, "trainPersonNumMat", 0);
	eigenValMat  = (CvMat *)cvReadByName(fileStorage, 0, "eigenValMat", 0);
	projectedTrainFaceMat = (CvMat *)cvReadByName(fileStorage, 0, "projectedTrainFaceMat", 0);
	pAvgTrainImg = (IplImage *)cvReadByName(fileStorage, 0, "avgTrainImg", 0);
	eigenVectArr = (IplImage **)cvAlloc(nTrainFaces*sizeof(IplImage *));
	for(i=0; i<nEigens; i++)
	{
		char varname[200];
		sprintf( varname, "eigenVect_%d", i );
		eigenVectArr[i] = (IplImage *)cvReadByName(fileStorage, 0, varname, 0);
	}

	// release the file-storage interface
	cvReleaseFileStorage( &fileStorage );

	return 1;
}

int findNearestNeighbor(float * projectedTestFace) {
  //double leastDistSq = 1e12;
char Buf[100];
Out->clear();
double leastDistSq = DBL_MAX;
int i, iTrain, iNearest = 0;

for(iTrain=0; iTrain<nTrainFaces; iTrain++)
{
  double distSq=0;
  for(i=0; i<nEigens; i++)
  {
    float d_i =	projectedTestFace[i] -
		projectedTrainFaceMat->data.fl[iTrain*nEigens + i];

        distSq += d_i*d_i; // Euclidean

  }
  sprintf(Buf,"%03d  ->  %f",iTrain+1,distSq);
  Out->add(Buf);
  if(distSq < leastDistSq){
     leastDistSq = distSq;
     iNearest = iTrain;
  }
}

return iNearest;
}

int loadFaceImgArray(char * filename) {
  FILE * imgListFile = 0;
char imgFilename[512];
char Buf[512];
int iFace, nFaces=0;

// open the input file
if( !(imgListFile = fopen(filename, "r")) )
{
	fprintf(stderr, "Can\'t open file %s\n", filename);
	return 0;
}
	// count the number of faces
while( fgets(imgFilename, 512, imgListFile) ) ++nFaces;
rewind(imgListFile);
	// allocate the face-image array and person number matrix
faceImgArr        = (IplImage **)cvAlloc( nFaces*sizeof(IplImage *) );
personNumTruthMat = cvCreateMat( 1, nFaces, CV_32SC1 );
	// store the face images in an array
for(iFace=0; iFace<nFaces; iFace++)
{
	// read person number and name of image file
	fscanf(imgListFile,
		"%s %s", Buf, imgFilename);
        *(personNumTruthMat->data.i+iFace)=iFace+1;		
		// load the face image
	faceImgArr[iFace] = cvLoadImage(imgFilename, CV_LOAD_IMAGE_GRAYSCALE);
		if( !faceImgArr[iFace] )
	{
		fl_alert("Can\'t load image from %s\n", imgFilename);
		return 0;
	}
}

fclose(imgListFile);

return nFaces;
}

void Save_Add() {
  char* file;
  char Buf[1024];
  playing=false;
  if(!strcmp(Name->value(),"")){
    fl_alert("You must be give name ");
    playing=true;
    return;
  }
  file = fl_file_chooser("Save Face", "Picture (*.{jpg,png,bmp,dib,sr,ras,pbm,pgm,ppm,tif,tiff})\t", NULL);
  if(file==NULL){
    playing=true;
    return;
  }
  fFace->Save(file);
  sprintf(Buf,"%s %s",Name->value(),file);
  fl_alert(Buf);
  List->add(Buf);
  SaveList();
  playing=true;
}

int LoadTrainData() {
  FILE * imgListFile = 0;
	char imgFilename[512];
	int iFace, nFaces=0;
	char * filename;


	// open the input file
	if( !(imgListFile = fopen("train.txt", "r")) )
	{
		fprintf(stderr, "Can\'t open file %s\n", filename);
		return 0;
	}

	// count the number of faces
	while( fgets(imgFilename, 512, imgListFile) ) ++nFaces;
	rewind(imgListFile);

	// allocate the face-image array and person number matrix
	faceImgArr        = (IplImage **)cvAlloc( nFaces*sizeof(IplImage *) );
	personNumTruthMat = cvCreateMat( 1, nFaces, CV_32SC1 );

	// store the face images in an array
	for(iFace=0; iFace<nFaces; iFace++)
	{
		// read person number and name of image file
		fscanf(imgListFile,
			"%d %s", personNumTruthMat->data.i+iFace, imgFilename);

		// load the face image
		faceImgArr[iFace] = cvLoadImage(imgFilename, CV_LOAD_IMAGE_GRAYSCALE);

		if( !faceImgArr[iFace] )
		{
			fprintf(stderr, "Can\'t load image from %s\n", imgFilename);
			return 0;
		}
	}

	fclose(imgListFile);

	return nFaces;
}

void SaveTrainData() {
}

void LoadList() {
  List->load("train.txt");
List->remove(List->size());
}

void SaveList() {
  if(List->size()<1)return;
char Buf[512];
FILE *fp;
fp=fopen("train.txt","wt");
if(fp){
  for(int i=1;i<=List->size();i++){
    sprintf(Buf,"%s\n",List->text(i));
    fputs(Buf,fp);
  }
  fclose(fp);    
   
     
}
else
  fl_alert("File Not opened");
}

AboutDlg::AboutDlg() {
  { Fl_Double_Window* o = window = new Fl_Double_Window(482, 329, "About");
    window->box(FL_PLASTIC_UP_BOX);
    window->color((Fl_Color)22);
    window->user_data((void*)(this));
    window->align(FL_ALIGN_CENTER);
    { Ok = new Fl_Return_Button(337, 285, 130, 30, "Ok");
      Ok->box(FL_PLASTIC_UP_BOX);
      Ok->color(FL_SELECTION_COLOR);
      Ok->callback((Fl_Callback*)cb_Ok);
    } // Fl_Return_Button* Ok
    { Info = new Fl_Browser(5, 16, 465, 256);
      Info->color((Fl_Color)31);
      Info->textcolor(4);
    } // Fl_Browser* Info
    o->set_modal();
    window->end();
  } // Fl_Double_Window* window
}

void AboutDlg::show() {
  Info->add("@c@b@i@l@C1 Face Recognation Sample ");
Info->add(" Programmed by Bluekid ");
Info->add(" http://derindelimavi.blogspot.com/");
Info->add(" adapted from 'Seeing With OpenCV Part 5 Implementing Eigenface '");
Info->add(" Servo magazine 05 - 2007 by Robin Hewitt");
Info->add(" it also includes Fl_OpenCv 0.85");
Info->add("@i@C1 Fl_OpenCv :  ");
Info->add("  is a widget which is render OpenCv image within the FLTK window");
Info->add(" FLTK is a cross-platform C++ GUI toolkit ");
Info->add(" ------------------------------------------------------");
Info->add(" Please Send me any suggestion, modification or bugs.");
Info->add(" Don't hesitate to contact me for any question");
Info->add(" I will be very grateful with your feedbacks.");
Info->add(" bluekid70@gmail.com");

window->show();
window->redraw();
}

void AboutDlg::hide() {
  window->hide();
}

void cb_Ok(Fl_Return_Button*o, void*w) {
  ((Fl_Window *)(o->parent()))->hide();
playing=true;
Fl::add_timeout(0.05, Playing_CB);
}
